package models;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.Serializable;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.util.Collection;
import java.util.Date;
import com.conveyal.gtfs.validator.json.FeedValidationResult;
import com.conveyal.gtfs.validator.json.LoadStatus;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import play.Logger;
import utils.DataStore;


/**
 * This represents where a feed comes from/came from.
 * @author mattwigway
 *
 */
public class FeedSource extends Model {
    private static DataStore<FeedSource> sourceStore = new DataStore<FeedSource>("feedsources");
    
    /**
     * The collection of which this feed is a part
     */
    @JsonIgnore
    public String feedCollectionId;
    
    /**
     * Get the FeedCollection of which this feed is a part
     */
    public FeedCollection getFeedCollection () {
        return FeedCollection.get(feedCollectionId);
    }
    
    public void setFeedCollection(FeedCollection c) {
        this.feedCollectionId = c.id;
    }
    
    /** The name of this feed source, e.g. MTA New York City Subway */
    public String name;
    
    /** Is this feed public, i.e. should it be placed in deployments and listed on the
     * public feeds page for download?
     */
    public boolean isPublic;
    
    /**
     * How do we receive this feed?
     */
    public FeedRetrievalMethod retrievalMethod;
    
    /**
     * When was this feed last fetched?
     */
    public Date lastFetched;
    
    /**
     * When was this feed last updated?
     */
    public Date lastUpdated;
    
    /**
     * From whence is this feed fetched?
     */
    public URL url;
    
    /**
     * Create a new feed. This also creates a user to own this feed.
     */
    public FeedSource (String name) {
        super();
        
        this.name = name;
        
        // create a user for this feed
        String username = this.name;
        int i = 0;
        
        // feed source names are not always unique. find a name that is.
        while (true) {
            if (User.getUserByUsername(username) != null) {
                i++;
                username = this.name + "_" + i;
            }
            else {
                break;
            }
        }
        
        // create a new user to own this feed source, with no password (a login key will be generated) and no email address
        User u = new User(username, null, null);
        u.active = true;
        u.admin = false;
        u.autogenerated = true;
        u.save();
        this.userId = u.id;
    }
    
    @Override
    public void setUser (User u) {
        throw new IllegalArgumentException("FeedSources are permanently associated with a single user");
    }
    
    /**
     * Fetch the latest version of the feed.
     */
    public void fetch () {
        if (this.retrievalMethod.equals(FeedRetrievalMethod.FETCHED_AUTOMATICALLY)) {
            Logger.info("not fetching feed {}, not a fetchable feed", this.toString());
            return;
        }
        
        // fetchable feed, continue
        FeedVersion latest = getLatest();
        
        // We create a new FeedVersion now, so that the fetched date is (milliseconds) before
        // fetch occurs. That way, in the highly unlikely event that a feed is updated while we're
        // fetching it, we will not miss a new feed.
        FeedVersion newFeed = new FeedVersion(this);
        
        // make the request, using the proper HTTP caching headers to prevent refetch, if applicable
        HttpURLConnection conn;
        try {
            conn = (HttpURLConnection) url.openConnection();
        } catch (IOException e) {
            Logger.error("Unable to open connection to {}; not fetching feed {}", url, this);
            return;
        }
        
        conn.setDefaultUseCaches(true);
        
        if (latest != null)
            conn.setIfModifiedSince(latest.updated.getTime());
        
        try {
            conn.connect();
        
            if (conn.getResponseCode() == HttpURLConnection.HTTP_NOT_MODIFIED) {
                Logger.info("Feed {} has not been modified", this);
                return;
            }

            // TODO: redirects
            else if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {
                Logger.info("Saving feed {}", this);

                File out = newFeed.newFeed();
                
                FileOutputStream outStream;
                
                try {
                    outStream = new FileOutputStream(out);
                } catch (FileNotFoundException e) {
                    Logger.error("Unable to open {}", out);
                    return;
                }
                
                // copy the file
                ReadableByteChannel rbc = Channels.newChannel(conn.getInputStream());
                outStream.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);
            }
            
            else {
                Logger.error("HTTP status {} retrieving feed {}", conn.getResponseMessage(), this);
                return;
            }
        } catch (IOException e) {
            Logger.error("Unable to connect to {}; not fetching feed {}", url, this);
            return;
        }
        
        // validate the fetched file
        // note that anything other than a new feed fetched successfully will have already returned from the function
        newFeed.hash();
        
        if (latest != null && newFeed.hash.equals(latest.hash)) {
            Logger.warn("Feed {} was fetched but has not changed; server operators should add If-Modified-Since support to avoid wasting bandwidth", this);
            newFeed.getFeed().delete();
            newFeed.dereference();
        }
        else {
            newFeed.userId = this.userId;
            newFeed.validate();
            newFeed.save();
        }
    }
    
    public String toString () {
        return "<FeedSource " + this.name + " (" + this.id + ")>";
    }
    
    public void save () {
        sourceStore.save(this.id, this);
    }
    
    /**
     * Get the latest version of this feed
     * @return the latest version of this feed
     */
    @JsonIgnore
    public FeedVersion getLatest () {
        FeedVersion latest = null;
    
        for (FeedVersion version : FeedVersion.getAll()) {
            // there could be feedsources in the datastore that haven't finished initializing
            if (this.id.equals(version.feedSourceId)) {
                if (latest == null || version.updated.after(latest.updated)) {
                    latest = version;
                }
            }
        }
        
        return latest;
    }
    
    @JsonInclude(Include.NON_NULL)
    public String getLatestVersionId () {
        FeedVersion latest = getLatest();
        return latest != null ? latest.id : null;
    }
    
    /**
     * We can't pass the entire latest feed source back, because it contains references back to this feedsource,
     * so Jackson doesn't work. So instead we specifically expose the validation results and the latest update.
     * @param id
     * @return
     */
    @JsonInclude(Include.NON_NULL)
    public Date getLastUpdated() {
        FeedVersion latest = getLatest();
        return latest != null ? latest.updated : null;
    }
    
    @JsonInclude(Include.NON_NULL)
    public FeedValidationResultSummary getLatestValidation () {
        FeedVersion latest = getLatest();
        return latest != null ? new FeedValidationResultSummary(latest.validationResult) : null;
    }
    
    public static FeedSource get(String id) {
        return sourceStore.getById(id);
    }

    public static Collection<FeedSource> getAll() {
        return sourceStore.getAll();
    }
    
    /**
     * Represents ways feeds can be retrieved
     */
    public static enum FeedRetrievalMethod {
        FETCHED_AUTOMATICALLY, // automatically retrieved over HTTP on some regular basis
        MANUALLY_UPLOADED, // manually uploaded by someone, perhaps the agency, or perhaps an internal user
        PRODUCED_IN_HOUSE // produced in-house in a GTFS Editor instance
    }
    
    /**
     * Represents a subset of a feed validation result, just enough for display, without overwhelming the browser
     * or sending unnecessary amounts of data over the wire
     */
    public static class FeedValidationResultSummary implements Serializable {
        public LoadStatus loadStatus;
        
        @JsonInclude(Include.ALWAYS)
        public String loadFailureReason;
        public Collection<String> agencies;
      
        public int errorCount;
        
        // statistics
        public int agencyCount;
        public int routeCount;
        public int tripCount;
        public int stopTimesCount;
        
        /** The first date the feed has service, either in calendar.txt or calendar_dates.txt */
        @JsonInclude(Include.ALWAYS)
        public Date startDate;
        
        /** The last date the feed has service, either in calendar.txt or calendar_dates.txt */
        @JsonInclude(Include.ALWAYS)
        public Date endDate;
        
        /**
         * Construct a summarized version of the given FeedValidationResult.
         * @param result
         */
        public FeedValidationResultSummary (FeedValidationResult result) {
            this.loadStatus = result.loadStatus;
            this.loadFailureReason = result.loadFailureReason;
            this.agencies = result.agencies;
            
            if (loadStatus == LoadStatus.SUCCESS) {
                this.errorCount = 
                        result.routes.invalidValues.size() +
                        result.stops.invalidValues.size() +
                        result.trips.invalidValues.size() +
                        result.shapes.invalidValues.size();
                
                this.agencyCount = result.agencyCount;
                this.routeCount = result.routeCount;
                this.tripCount = result.tripCount;
                this.stopTimesCount = result.stopTimesCount;
                this.startDate = result.startDate;
                this.endDate = result.endDate;
            }
        }
    }
     }
